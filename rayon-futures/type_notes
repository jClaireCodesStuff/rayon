type notes

pub struct RayonFuture<T, E>
    T -- return ok
    E -- return err

struct ScopeFuture<'scope, F, S>
    

struct ScopeFutureContents<'scope, F, S> 
    F: Future + Send + 'scope
    S: ScopeHandle<'scope>


struct ArcScopeFuture<'scope, F, S>
    newtype Arc<ScopeFuture>


struct ScopeFutureWrapped<'scope, F: 'Scope, S>
    newtype PhantomData<(&'scope F, S)>
    // This is a really interesting beastie
    // casts *const &self ->
    //       *const ArcScopeFuture
    //
    // in order to call `Notify`

    // I suspect such shenanigans are no longer necessary
    // with the new Waker but it almost seems a shame to let
    // it go.

trait ScopeFutureTrait<T, E> {
    fn probe(&self) -> bool;
    // returns true when future is COMPLETE

    fn poll(&self) -> Poll<T>
    // pass through to the wrapped future

    fn cancel(&self)
    // no longer care about the result of the future

----

Entry point is 

trait ScopeFutureExt<'scope>
    fn spawn_future<F>
        (&self, future: F) 
        -> RayonFuture<F::Output>
    where
        F: Future + Send + 'scope


struct RayonFuture
    fn rayon_wait(self) -> Result<T, E>

    impl Drop
    impl Debug
    impl Future

    auto impl Send
    auto impl Unpin
    auto impl Sync

The only required method is `Future::poll`


====

`ScopeFuture` and `ScopeFutureContents`

`ScopeFuture` is arc-boxed and exists for as long as rayon cares about the scoped future. `ScopeFutureContents` is protected by a `Mutex`.  Between the two the fields are:

(outside the `Mutex`)
 - state
   	STATE_COMPLETE
	STATE_EXECUTING
	STATE_EXECUTING_UNPARKED
	STATE_PARKED
	STATE_UNPARKED
(inside the `Mutex`)
 - spawn 
	originally `Option<Spawn<CU<F impl Future>>>`
	the future, if it isn't complete
 - this
	Arc-pointer that keeps ScopeFuture alive
 
 - scope Option<S impl ScopeHandle<'scope>>
	holds the lifetimes of `F` open
	allows polling the inner future to be spawned
	as a rayon Task (which is one-shot)

 - waiting_task:
	originally `Option<Task>`
	The task that most recently polled the outer future.

 - result: Poll<CUOutput<F>>
	the result of the inner future

 - canceled: bool

Also related types are 
 - `ArcScopeFuture`
	an Arc-pointer to ScopeFuture

 - CU<F> = CatchUnwind<AssertUnwindSafe<F>>
	`CatchUnwind impl Future` 
	with the Future::Output transformed to 
	Result<_, Box<dyn Any + Send + 'static>>

 - CUOutput<F> = <CU<F> as Future>::Output
	typealias for 
	Result<{inner Output}, Box<dyn Any + Send + 'static>>

And the type parameters:
 - F: Future + Send + 'scope
	the inner Future type

 - S: rayon_core::internal::task::ScopeHandle<'scope>
 	`ScopeHandle` is an unsafe trait.  
	Not sure why I can't get Rustdoc to document it
	It has three methods:
        /// Execute a Task once.
        /// UNSAFE: do not drop or consume S until the task
        /// has executed.  The other methods consume S
	unsafe fn spawn_task
		(&self, task: Arc<T impl Task + 'scope>)

	fn panicked(self, err: Box<Any + Send>);
	fn ok(self)

===

`ScopeFutureTrait` is a confusing name, changing to
`ScopeFutureEscapeSafe`

This trait contains methods which can be safely called even if `'scope` has been escaped.

